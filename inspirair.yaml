modbus:
  id: modbus1

modbus_controller:
  - id: modbus_device
    ## the Modbus device addr
    address: 0x2
    modbus_id: modbus1
    setup_priority: -10
    
interval:
  # Activate God mode periodically (needed to retrieve fan values)
  # Interval needed because it get deactivated automatically after a while
  - interval: 5min
    then:
      select.set:
        id: user_level
        option: "God"

sensor:
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Exhaust Flow
    register_type: holding
    address: 0x0164
    unit_of_measurement: "m3/h"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Supply Flow
    register_type: holding
    address: 0x0165
    unit_of_measurement: "m3/h"
    entity_category: diagnostic
  
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Exhaust Fan Speed (Feedback)
    register_type: holding
    address: 0x0162
    unit_of_measurement: "rpm"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Supply Fan Speed (Feedback)
    register_type: holding
    address: 0x0163
    unit_of_measurement: "rpm"
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Input Air Temperature
    register_type: holding
    address: 0x015E
    unit_of_measurement: "°C"
    lambda: return x * 0.01;
    accuracy_decimals: 2
    entity_category: diagnostic
  
  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Extracted Air Temperature
    register_type: holding
    address: 0x015F
    unit_of_measurement: "°C"
    lambda: return x * 0.01;
    accuracy_decimals: 2
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Supply Air Temperature
    register_type: holding
    address: 0x0160
    unit_of_measurement: "°C"
    lambda: return x * 0.01;
    accuracy_decimals: 2
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    id: output_air_temperature
    register_type: holding
    address: 0x0161
    unit_of_measurement: "°C"
    lambda: return x * 0.01;
    accuracy_decimals: 2
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Air Pressure
    register_type: holding
    address: 0x0166
    unit_of_measurement: "Pa"
    lambda: return x * 0.1;
    accuracy_decimals: 2
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Stepper Motor Reduction Coefficient
    register_type: holding
    address: 0x0303
    accuracy_decimals: 0
    entity_category: diagnostic

  - platform: modbus_controller
    register_type: holding
    address: 0x0400
    name: Exhaust Fan Voltage
    unit_of_measurement: "V"
    lambda: return x * 0.001;
    accuracy_decimals: 2

  - platform: modbus_controller
    register_type: holding
    address: 0x0401
    name: Supply Fan Voltage
    unit_of_measurement: "V"
    lambda: return x * 0.001;
    accuracy_decimals: 2

  - platform: modbus_controller
    register_type: holding
    address: 0x0402
    name: Exhaust Fan Speed
    unit_of_measurement: "RPM"

  - platform: modbus_controller
    register_type: holding
    address: 0x0403
    name: Supply Fan Speed
    unit_of_measurement: "RPM"

select:
  - platform: modbus_controller
    id: user_level
    name: User Level
    use_write_multiple: true
    address: 0x0010
    optionsmap:
      "Noob": 0
      "Useless": 2345
      "Interesting": 12054
      "God": 34102
      "-": 65535

  - platform: modbus_controller
    name: Regulation Mode
    use_write_multiple: true
    address: 0x0100
    optionsmap:
      "Constant Flow": 0
      "Constant Pressure": 1
      "Constant Speed": 2

  - platform: modbus_controller
    name: Ventilation Preset
    use_write_multiple: true
    address: 0x0101
    optionsmap:
      "Absence": 0
      "Daily": 1
      "Boost": 2
      "Guest Party": 3
      "Max": 4

  - platform: modbus_controller
    name: Insuflation Filter Type
    use_write_multiple: true
    address: 0x01EA
    optionsmap:
      "Unknown": 0
      "Dust": 1
      "Pollen": 2
      "Particules": 3
      "Fine Particules": 4
      "Bacteria": 5
      "VOC": 6
      
  - platform: modbus_controller
    name: Exhaust Filter Type
    use_write_multiple: true
    address: 0x01EB
    optionsmap:
      "Unknown": 0
      "Dust": 1
      "Pollen": 2
      "Particules": 3
      "Fine Particules": 4
      "Bacteria": 5
      "VOC": 6
  
  - platform: modbus_controller
    name: Bypass Status
    use_write_multiple: true
    address: 0x0300
    optionsmap:
      "Idle": 0
      "Full Closed": 1
      "Full Open": 2
      "-": 65535

text_sensor:
  - platform: modbus_controller
    register_type: holding
    address: 0x0022
    raw_encode: HEXBYTES
    name: Product Id
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 3471: return std::string("VEX 40 T Classic");
        case 3472: return std::string("VEX 40 T Premium");
        case 3473: return std::string("Inspirair Top 300 Classic");
        case 3474: return std::string("Inspirair Top 300 Premlium");
        case 3475: return std::string("Inspirair Top 450 Classic");
        case 3476: return std::string("Inspirair Top 450 Premlium");
        case 3477: return std::string("Inspirair Top 300 ERV");
        case 3478: return std::string("Inspirair Top 450 ERV"); // not sur of this value, documentation is truncated
        case 2: return std::string("Summer");
        default: return std::string("Unknown");
      }
      return x;

  - platform: modbus_controller
    register_type: holding
    address: 0x0180
    raw_encode: HEXBYTES
    name: Error Code
    entity_category: diagnostic
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("No Error");
        case 49: return std::string("No Product Id");
        case 50: return std::string("No Primary Setup");
        case 53: return std::string("Pressure Sensor Defect");
        case 70: return std::string("Dry Contact Active");
        case 72: return std::string("Humidity Sensor Defect");
        case 76: return std::string("CO2 Sensor Defect");
        case 81: return std::string("BCA Absente");
        case 82: return std::string("Echec BCA");
        case 83: return std::string("Défaut BCA PréChauf. Ext.");
        case 84: return std::string("Défaut PréChauffage Int.");
        case 85: return std::string("Défaut BCA PostChauf. Ext.");
        case 90: return std::string("Echec Test FireDamper");
        case 91: return std::string("FireDamper Fermé");
        case 182: return std::string("Défaillance MVE");
        case 183: return std::string("Défaillance MVI");
        case 239: return std::string("Défaut sonde Rejet");
        case 240: return std::string("Défaut sonde Extérieur");
        case 241: return std::string("Défaut sonde Insufflation");
        case 251: return std::string("Défaut Sonde VMC");
        default: return std::string("Unknown");
      }
      return x;


  - platform: modbus_controller
    register_type: holding
    address: 0x0590
    raw_encode: HEXBYTES
    name: Current USB Behaviour
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("None");
        case 1: return std::string("Host");
        case 2: return std::string("Device");
        default: return std::string("Auto detecting");
      }
      return x;

  - platform: modbus_controller
    register_type: holding
    address: 0x0591
    raw_encode: HEXBYTES
    name: Current USB Behaviour Step
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      // Enum = "0:NotInit/1:InitHost/2:RunHost/3:DeInitHost/4:InitDevice/5:RunDevice/6:DeInitDevice/7:InitNone/8:RunNone"
      switch (value) {
        case 0: return std::string("Not Initialized");
        case 1: return std::string("Initializing Host");
        case 2: return std::string("Running Host");
        case 3: return std::string("De-initializing Host");
        case 4: return std::string("Initializing Device");
        case 5: return std::string("Running Device");
        case 6: return std::string("De-initializing Device");
        case 7: return std::string("Initializing None");
        case 8: return std::string("Running None");
        default: return std::string("Auto detecting");
      }
      return x;

  - platform: modbus_controller
    register_type: holding
    address: 0x0175
    raw_encode: HEXBYTES
    name: Season
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 1: return std::string("Winter");
        case 2: return std::string("Summer");
        default: return std::string("Unknown");
      }
      return x;

  - platform: modbus_controller
    name: Bypass Mode
    register_type: holding
    address: 0x0103
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 1: return std::string("Auto");
        default: return std::string("Manual");
      }
      return x;

  - platform: modbus_controller
    name: Bypass Current Position
    register_type: holding
    address: 0x015C
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 1: return std::string("Open");
        case 2: return std::string("Half Closed");
        case 3: return std::string("Closed");
        default: return std::string("Unknown");
      }
      return x;

  - platform: modbus_controller
    register_type: holding
    address: 0x0404
    raw_encode: HEXBYTES
    name: Fan Config
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 1: return std::string("B");
        case 2: return std::string("A");
        default: return std::string("None");
      }
      return x;

switch:
  - platform: modbus_controller
    register_type: holding
    address: 0x01ED
    name: Radon Mode

number:
  - platform: modbus_controller
    register_type: holding
    value_type: S_WORD
    address: 0x01E6
    name: Confort Temperature
    step: 0.1
    lambda: return x * 0.01;
    write_lambda: return static_cast<short>(x * 100);
    use_write_multiple: true
    
  - platform: modbus_controller
    register_type: holding
    value_type: S_WORD
    address: 0x01EC
    name: Bypass Switch Temperature
    step: 0.1
    lambda: return x * 0.01;
    write_lambda: return static_cast<short>(x * 100);
    use_write_multiple: true

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Bypass Open Angle
    register_type: holding
    address: 0x0301
    unit_of_measurement: "°"
    use_write_multiple: true

  - platform: modbus_controller
    modbus_controller_id: modbus_device
    name: Bypass Close Angle
    register_type: holding
    address: 0x0302
    unit_of_measurement: "°"
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0410
    name: Exhaust Flow Setpoint - Absence
    icon: mdi:fan-speed-1
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0411
    name: Supply Flow Setpoint - Absence
    icon: mdi:fan-speed-1
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0412
    name: Exhaust Flow Setpoint - Daily
    icon: mdi:fan-speed-2
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0413
    name: Supply Flow Setpoint - Daily
    icon: mdi:fan-speed-2
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0414
    name: Exhaust Flow Setpoint - Boost
    icon: mdi:fan-plus
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0415
    name: Supply Flow Setpoint - Boost
    icon: mdi:fan-plus
    use_write_multiple: true
    
  - platform: modbus_controller
    register_type: holding
    address: 0x0416
    name: Exhaust Flow Setpoint - Guest
    icon: mdi:fan-speed-3
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0417
    name: Supply Flow Setpoint - Guest
    icon: mdi:fan-speed-3
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0418
    name: Exhaust Flow Setpoint - Max
    icon: mdi:fan-plus
    use_write_multiple: true

  - platform: modbus_controller
    register_type: holding
    address: 0x0419
    name: Supply Flow Setpoint - Max
    icon: mdi:fan-plus
    use_write_multiple: true

# button:
#   - platform: modbus_controller
#     id: save
#     register_type: holding
#     address: 0x0014
#     value_type: U_WORD
#     use_write_multiple: true
#     write_lambda: |-
#       payload.push_back(22577);
#       return 0 ;